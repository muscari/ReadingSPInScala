##第15章 ケースクラスとパターンマッチ

この章では、通常のカプセル化されていないデータ構造を書くときに有用なケースクラス（case classes）とパターンマッチ(pattern matching)の構文について書かれている。

###15.1 単純なサンプル
変数、数値、単項・二項演算を定義する。

```scala
abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Dobule) extends Expr
case class UnOp(operator : Strign, arg : Expr) extends Expr
case class BinOp(operator: String, left:Expr, right:Expr) extends Expr
```

####15.1.1 ケースクラス
各サブクラスの前に”case”をつけることで、クラスケースを定義できる。 

○クラスケースの４つの利点

1. コンパイル時にクラスと同じ名前のファクトリーメソッドを追加する。  
	・インスタンスを作成するときに、"new"演算子がいらない。  

2. コンパイラーは、ケースクラスのパラメータリスト内のすべてのパラメータに暗黙のうちに"val"プレフィックスをつける。
	・パラメータはフィールドとして管理される。  
	・イミュータブルな変数として扱える。  

3. コンパイラーがクラスに"toString","hashCode","equals"メソッドの実装を自動で追加してくれる。  
	・”==”でequalsを呼び出すことで、ケースクラス間の比較が容易になる。  

4. コンパイラは変更を加えたコピーを作成するために、"copy"メソッドを追加する。  
	・１つか２つの属性が異なる、ほぼ同じクラスのインスタンスを作成するときに便利。  
	・名前付きパラメータを使うことで、変更部分のみ異なるインスタンスの作成ができる。

```scala
val v = Var("x")
val op = BinOp("+", Number(1),v)
op.copy(operator = "-")//上のopの"+"が"-"に変わったインスタンスが作成される。

```

####感想
ケースクラスを使用することで、他のプログラム言語よりも簡潔に短いコードを書くことができるのがとても印象的であった。特に、	"copy"メソッドが実装されていることが魅力的であり、属性が変化する場所のみを変更したインスタンスの作成が１行で実行できるのが効率にもつながると考えられる。


####15.1.2 パターンマッチ
条件分岐のケースを単純化するために"scala"ではパターンマッチが用意されている。パターンマッチには"case"キーワードを先頭に置く一連の選択肢が含まれている。  
パターンマッチの種類としては、   
1. 定数パターン  
2. 変数パターン  
3. ワイルドカードパターン  
4. コンストラクターパターン  
の４つのパターンが用意されている。

match式の書き方  
```scala
＜セレクター式＞ match {<選択肢>}
```

####15.1.3 matchとswitchの違い
大きく３つの違いがあり、  
1. matchはscalaの式であり、式の評価時に例外が投じなければ、必ず結果値を返す。  
2. scalaの選択肢は、次の選択肢に「続けて落ちて」いかない。  
3. マッチするパターンがなければ、Match Errorという例外が投げられる。
  
ここでの疑問として、Match Errorというレスポンスの型がなんなのかが気になった。  

###15.2 パターンの種類
ここでは、４つのパターンについて詳しく説明していく。  

####15.2.1 ワイルドカードパターン
ワイルドカードパターン(_)はあらゆるオブジェクトにマッチする。  
```scala
def hoge(expr: Expr): Unit = expr match {
	case BinOp (op, left, right) => 
		println(expr + " is a binary operation")
	case _ =>
}

```	

ここでは、BinOpが二項演算になっているかどうかを調べているだけで、中身には注意を払っていない。  
また、上記のプログラムは以下のようにも書き換えることができる。　

```scala
def hoge(expr: Expr): Unit = expr match {
	case BinOp (_, _, _) => 
		println(expr + " is a binary operation")
	case _ => println("It's something else")
}

```		
この２つの使い分け方として、変数の束縛が関係してくる。上の場合では、ワイルドカードパターンを使用していないため、マッチ後の処理として、条件内の変数を使用することができる。逆にワイルドカードパターンを使用している場合は、それができない。	
  
####15.2.2 定数パターン
定数は自分自身としかマッチを行わない。例としては、5,true,"hello"などである。  
処理として、任意のvalやシングルトンオブジェックトを定数としても扱うことができ、シングルトンオブジェクトのNilは、空リストだけにマッチするパターンである。

####15.2.3変数パターン
変数パターンは任意のオブジェクトにマッチし、ワイルドカードパターンと異なり、オブジェクトに変数を束縛する。変数パターンの例を以下に示す。		


```scala
def hoge(expr: Expr): String = expr match {
	case 0 => "zero"
	case somethingElse => "not zero: " + somethingElse
}

```
この例では、前者のケースで、0という定数パターンを定義している。また、後者では、somethingElseと定義されているが、このプログラムの振る舞いとして、exprに0以外の数字または文字列が引数として渡されると、すべてsomethingElseとされる。  
かつ、変数の束縛があるため、オブジェクトの操作が可能となる。この、somethingElseの条件式はデフォルトケースと呼ぶ。

#####15.2.3.1 変数か定数か
定数Eとπを使用して、定数パターンと変数パターンのどちらが使用されるかの区別を行う。

```scala
import math.{E, Pi}
def hoge(E: Expr): String = E match {
	case Pi => "strange math ? Pi = " + Pi
	case _ => "OK"
}

```
上記プログラムでは、入力さえれたEは定数パターンとして判別を行い、"OK"が出力される。  
scalaでは、先頭が小文字になっている単純名はパターン変数、そうでないものは定数と見なされる。下記プゴグラムで違いを見てみる。

```scala
val pi = math.Pi
def hoge(E: Expr): String = E match {
	case pi =>"strange math? Pi = " + pi
	case _ => "OK"
}

```	
この例では、piは変数パターンとして扱われるため、すべてpiとして認識される。そのため、デフォルトケースを追加した場合、コンパイルエラーとなる。

####15.2.4 コンストラクターパターン
コンストラクタパターンは、BinOp("+", e, Number(0))のようにして、オブジェクトのパターンマッチを行う。コンストラクタパターンを使う上で便利なことは、任意の深さまでのチェックが可能となる。

```scala
def hoge(expr: Expr): Unit = expr match {
	case BinOp("+", e, Number(0)) => println("a deep match")
	case _ =>
}

```	
この例では、オブジェクトがBinOpであるというだけでなく、第一引数が"+"、第二引数がなんらかの変数、第三引数が数字の０であるかどうかまでもチェックしている。
  

####感想
いくつかのパターンマッチについて勉強をしたが、印象に残ったことして、定数パターンか変数パターンかの区別をつけるところが難しかった。したがって、コンストラクターパターンを使用した例で、どのような挙動を行うかの練習などを行った。また、手続き型言語では、複数の条件分岐で書かなければならないことを、scalaでは１行で実装できるということが便利だと感じた。	

####15.2.5 シーケンスパターン  
ListやArrayなどのシーケンス型に対するパターンマッチも可能である。
```scala
def hoge(expr: Any): Unit = expr match {
	case List(0, _, _) => println("found it")//固定長のシーケンスパターン
	case List(0, _*) => println("found it")//任意の長さのシーケンスパターン
}

```	
####15.2.6 タプルパターン
異なる型を要素として持てるタプルにマッチさせることができる。  
タプルは(a,b,c)のように表す。


####15.2.7 型付きパターン
型付きパターンは、型のテストと型のキャストとして扱える。
```scala
def generalSize(x:Any) = x match {
	case s:String => s.length
	case m:Map[_,_] => m.size
	case _ => -1
}

```	
引数はAny型なので、どのような値も引数としてとり、マッチした変数に応じて長さを返す。  
String型かどうかを調べるときには、isInstanceOf[Strign]を使い
String型にキャストするときは、asInstanceOf[String]を使う。
このStringのところには、自分自身で作成したクラスなどを入れることで、チェックもできる。

#####15.2.7.1 型消去(type erasure)
以下に、Mapの引数がIntとIntであるかどうかの関数を定義する。
```scala
def isIntIntMap(x:Any) = x match {
	case m: Map[Int, Int] => true
	case _ => false
}

```	
しかし、上記の関数では正しい挙動を示してくれない。scalaでは型が消去されるため、パターンマッチの時に比較をできない。だが、配列の時は型消去が原則の例外となる。  
この章で疑問として上がったのが、15.2.4で学習したコンストラクタパターンの時には、比較ができていたのではないかということである。引数として、Intの引数のみをチェックすれば、型消去の影響は受けないのではないかと考えた。

####15.2.8 変数の束縛
変数名、@記号、パターンの順序で書くことで、変数束縛パターンとなる。以下が、絶対値演算を２度適用しているときに、適用した数字を返す例である。
```scala
def checkAbs(expr:Expr):Expr = expr match {
	case UnOp("abs", e @ UnOp("abs", _)) => e
	case _ =>
}
```	


###15.3 パターンガード
scalaではパターンを線形なものに制限しているため以下のようなプログラムでは、パターン変数が複数回にわたって使用されているためエラーがでる。
```scala
def simplifyAdd(e: Expr) = e match{
	case BinOp("+", x, x) => BinOp("*", x, Number(2))
	case _ => e
}
```	
このような場合、if文を使ってパターンガードを書くことで実現する。
```scala
def simplifyAdd(e: Expr) = e match{
	case BinOp("+", x, x) if x == y => BinOp("*", x, Number(2))
	case _ => e
}

```	
###15.4 パターンのオーバーラップ
パターンでは、書かれた順序でテストされるため、書く順序をしっかりと考慮する必要がある。
つまり、全ての条件を包括するように書くことが望ましい。

###15.5 シールドクラス
パターンマッチを書くときに可能なケースを全て網羅するようにしなければならない。
ケースクラスのスーパークラスをシールド（sealed）クラスにすることで、他のサブクラスを追加できないようにし、すでに知っているサブクラスのみを考えればよい。シールドクラスを継承するケースクラスを使ってマッチ式を書くとコンパイラは対応していないパターンの組み合わせをチェックして警告メッセージで知らせてくれる。

####感想
今回も、いくつかのパターンマッチについて学習を行ったが、型付きパターンは引数にAnyをとり、そのクラスごとに処理を定義できるという点から、とても便利なマッチングであると感じた。また、シールドクラスを使用することで、パターンの組み合わせの漏れを確認できることから、より完成度の高いプログラムの作成に役立てると感じた。




