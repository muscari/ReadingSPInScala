## 第16章　リストの操作

この章は、scalaのデータ構造の１つであるList（リスト）についての説明である。

### 16.1 リストリテラル
リストは'a','b','c'を要素とするリストはList('a','b','c')で表され、配列の違いとしてリストはイミュータブル（値の変更ができない、要素の追加ができない）であり、再帰的な構造を持つ。

```scala
val diag3:List[List[Int]] = List(
			 List(1,0,0),
			 List(0,1,0),
			 List(0,0,1))
```

再帰的な構造の例としては、以下の階乗を求める例のように、関数の中で関数を呼び出している状況を指す。

```scala
def Kaijyou(n: Int): Int = n match {
	case 0 => 1
	case n => n * Kaijyou(n - 1)
}
```


### 16.2 List型
配列と同様に、リストの中の要素はすべて同じ型になっている。T型の要素を集めたリストの型はList[T]となる。また、リスト型は共変であり、S型がT型のサブ型ならばList[S]はList[T]のサブ型である。例をあげれば、List[String]はList[Object]のサブ型である。

### 16.3 リストの構築
リストはNilと::(コンス)の２つから組み立てられる。Nilは空リストを指し、::はx :: xs :: NilとすることでList(x,xs)と同等の意味になる。

### 16.4 リストに対する基本操作
リストは以下の３つの操作によって表現される。
1. head:リストの先頭要素を返す
2. tail:先頭要素を除くすべての要素から構成されるリストを返す
3. isEmpty:リストがからのときtrueを返す。

### 16.5 リストパターン
リストはパターンマッチで分解することができる。List(...)という形式のパターンを使用すれば、リストのすべての要素をマッチさせることができる。

```scala
val fruit = List("apples", "oranges", "pears")
val List(a,b,c) = fruit
//結果
a: String = apples
b: String = oranges
c: String = pears

val a :: b :: rest = fruit
//結果
a: String = apples
b: String = oranges
rest: List[String] = List(pears)
```

１つ目の例では、リストの長さが３のリストにマッチし、パターン変数a,b,cに３つの要素を束縛する。リストの長さがあらかじめわからない場合は::を使ってマッチさせる。２つ目の例では、長さ２以上のリストにマッチする。  
ここでの疑問点は、a,b,restの３つの変数を与えたときに、なぜrestのみList型になるのかという点である。  
これは、::が最後の文字がコロンなので右結合となるからA :: B :: C はA :: (B :: C)となるため、a, bは文字列として返されるが、残りの１つはリストとなるからである。

