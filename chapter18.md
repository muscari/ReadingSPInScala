## 第18章　ステートフルオブジェクト
これまでの章では、関数型オブジェクト（イミュータブル）に焦点を当ててきたが、それは、ミュータブルな状態を持たないオブジェクトという考え方を理解することが大切だからである。ステートフルオブジェクトは、時間とともに変化する実世界のオブジェクトを自然にモデリングすることができる。  
この章では、ステートフルオブジェクトとは何か？またその表現をするためのScalaの構文はどのようなものか？を説明する。

### 18.1 どのようなオブジェクトがステートフルなのか
純粋関数型オブジェクトとステートフルオブジェクトには、実装を見なくてもわかる大きな違いがある。純粋関数型オブジェクトの場合、メソッドを呼び出したり、フィールドを間接参照したりするときに、必ず同じ結果値が返される。
例えば、以下のプログラムではcs.headを実行すれば必ず'a'が返される。
これは、csリストの定義から、head関数の呼び出しまでの間に、リストをレシーバとする操作がいくつ行われても変化はしない。

```scala
val cs = List('a','b','c')
```

varがある場合、ステートフルオブジェクトであると連動することが多いがそのようにならないこともある。  
例えば、ミュターブルな状態を持つ他のオブジェクトに対して、メソッド呼び出しを転送していれば、varを定義・継承していなくても、そのクラスはステートフルになる。また、その逆もあり得る。varを持っていても、純粋関数型クラスになるものもある。以下に例を示す。


```scala
class Keyed{
	def computeKey:Int = ...//この処理には時間がかかる
}

class MemoKeyed extends Keyed{
	private var KeyCache: Option[Int] = None
	override def computeKey: Int = {
		if (!keyCache.isDefined) keyCache = Some(super.computeKey)
		keyCache.get
	}
}
```
computeKeyがvarを読み書きしないのであれば、computeKeyの結果値をキャッシュすることでKeyedの処理効率をあげることができる。
MemoKeyedでは、computeKeyの操作結果が２度目に要求されたときには、computeKeyをもう一度実行しなくても、keyCacheに格納された値を返すことができる。この処理は、スピードの差を除けば、KeyedとMemoKeyedのふるまいは全く同じである。つまり、MemoKeyedはvarを持つが純粋関数型ということになる。

### 18.2 再代入可能な変数とプロパティ
再代入可能な変数には、値の取得(get)と新しい値の設定(set)という基本操作がある。Scalaでは、なんらかのオブジェクトの公開・限定公開メンバーになっているvarに関しては、暗黙のうちにゲッター・セッターが定義される。var xのゲッター名はx、セッター名はx_=となる。

### 18.3 ケーススタディ：離散イベントシュミレーション
割愛

### 18.4 デジタル回路のための言語
割愛

### 18.5　シミュレーションAPI
割愛

### 18.6 デジタル回路のシミュレーション
割愛

### 18.7  まとめ
本章では、ミュータブルな状態と階層関数を併用する方法を示した。






